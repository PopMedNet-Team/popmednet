{"version":3,"sources":["knockout.mapping.js"],"names":["factory","require","exports","module","define","ko","Error","mapping","unionArrays","i","j","k","args","arguments","l","length","obj","res","push","extendObject","destination","source","destType","key","hasOwnProperty","getType","bothArrays","merge","obj1","obj2","merged","fillOptions","rawOptions","otherOptions","options","recognizedRootProperties","property","Object","ignore","mergeArrays","include","copy","observe","defaultOptions","mappedProperties","copiedProperties","a","b","undefined","utils","arrayGetDistinctValues","concat","withProxyDependentObservable","dependentObservables","callback","localDO","dependentObservable","read","owner","realDeferEvaluation","deferEvaluation","realIsPure","pure","isRemoved","wrap","DO","tmp","realKoDependentObservable","isWriteable","isWriteableObservable","wrapped","arrayRemoveItem","apply","write","val","__DO","realDependentObservable","fn","computed","result","updateViewModel","mappedRootObject","rootObject","parentName","parent","parentPropertyName","mappedParent","isArray","unwrapObservable","isMapped","previousMapping","mappingProperty","callbackParams","data","hasCreateCallback","create","Function","createCallback","Array","skip","emptyReturn","hasUpdateCallback","update","updateCallback","params","target","observable","alreadyMapped","visitedObjects","get","changes","hasKeyCallback","keyCallback","x","isObservable","observableArray","mappedRemove","valueOrPredicate","predicate","value","remove","item","mappedRemoveAll","arrayOfValues","arrayOfKeys","filterArrayByKey","arrayIndexOf","mappedDestroy","destroy","mappedDestroyAll","mappedIndexOf","keys","mappedGet","mappedCreate","newValue","currentArrayKeys","sort","newArrayKeys","editScript","compareArrays","ignoreIndexOf","unwrappedRootObject","itemsByKey","optimizedKeys","index","newContents","passedOver","mappedItem","fullPropertyName","escapePropertyNameComponent","status","getItemByKey","ignorableIndexOf","event","arrayChanged","arrayForEach","change","canHaveProperties","save","visitPropertiesOrArrayEntries","indexer","prevMappedProperty","retval","valueToWrite","hasCreateOrUpdateCallback","array","ignoreIndices","mapKey","arrayMap","visitorCallback","propertyName","object","type","getPropertyName","escapedIndexer","replace","SimpleObjectLookup","values","this","existingIndex","ObjectLookup","buckets","findBucket","bucketKey","e","bucket","mappingNesting","_defaultOptions","viewModel","unwrapped","fromJS","jsObject","pop","fromJSON","jsonString","prototype","slice","call","parseJson","toJS","resetDefaultOptions","visitModel","toJSON","replacer","space","plainJavaScriptObject","stringifyJson","constructor","Date","propertyValue","unwrappedRootMappingProperty","previouslyMappedValue"],"mappings":"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","file":"knockout.mapping.min.js","sourcesContent":["/*!\n * Knockout Mapping plugin v2.6.0\n * (c) 2013 Steven Sanderson, Roy Jacobs - http://knockoutjs.com/\n * License: MIT (http://www.opensource.org/licenses/mit-license.php)\n */\n(function(factory) {\n    'use strict';\n\n    /*jshint sub:true,curly:false*/\n    /*global ko,require,exports,define,module*/\n\n    if (typeof require === \"function\" && typeof exports === \"object\" && typeof module === \"object\") {\n        // CommonJS or Node: hard-coded dependency on \"knockout\"\n        factory(require(\"knockout\"), exports);\n    }\n    else if (typeof define === \"function\" && define[\"amd\"]) {\n        // AMD anonymous module with hard-coded dependency on \"knockout\"\n        define([\"knockout\", \"exports\"], factory);\n    }\n    else {\n        // <script> tag: use the global `ko` object, attaching a `mapping` property\n        if (typeof ko === 'undefined') {\n            throw new Error('Knockout is required, please ensure it is loaded before loading this mapping plug-in');\n        }\n        factory(ko, ko.mapping = {});\n    }\n}(function(ko, exports) {\n    /*jshint sub:true,curly:false*/\n    'use strict';\n\n    ko.mapping = exports;\n\n    var DEBUG=true;\n    var mappingProperty = \"__ko_mapping__\";\n    var realKoDependentObservable = ko.dependentObservable;\n    var mappingNesting = 0;\n    var dependentObservables;\n    var visitedObjects;\n    var recognizedRootProperties = [\"create\", \"update\", \"key\", \"arrayChanged\"];\n    var emptyReturn = {};\n\n    var _defaultOptions = {\n        include: [\"_destroy\"],\n        ignore: [],\n        copy: [],\n        observe: []\n    };\n    var defaultOptions = _defaultOptions;\n\n    function unionArrays() {\n        var args = arguments,\n            l = args.length,\n            obj = {},\n            res = [],\n            i, j, k;\n\n        while (l--) {\n            k = args[l];\n            i = k.length;\n\n            while (i--) {\n                j = k[i];\n                if (!obj[j]) {\n                    obj[j] = 1;\n                    res.push(j);\n                }\n            }\n        }\n\n        return res;\n    }\n\n    function extendObject(destination, source) {\n        var destType;\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key) && source[key]) {\n                destType = exports.getType(destination[key]);\n                if (key && destination[key] && destType !== \"array\" && destType !== \"string\") {\n                    extendObject(destination[key], source[key]);\n                }\n                else {\n                    var bothArrays = exports.getType(destination[key]) === \"array\" && exports.getType(source[key]) === \"array\";\n                    if (bothArrays) {\n                        destination[key] = unionArrays(destination[key], source[key]);\n                    }\n                    else {\n                        destination[key] = source[key];\n                    }\n                }\n            }\n        }\n    }\n\n    function merge(obj1, obj2) {\n        var merged = {};\n        extendObject(merged, obj1);\n        extendObject(merged, obj2);\n\n        return merged;\n    }\n\n    exports.isMapped = function(viewModel) {\n        var unwrapped = ko.utils.unwrapObservable(viewModel);\n        return unwrapped && unwrapped[mappingProperty];\n    };\n\n    exports.fromJS = function(jsObject /*, inputOptions, target*/) {\n        if (arguments.length === 0) {\n            throw new Error(\"When calling ko.fromJS, pass the object you want to convert.\");\n        }\n        try {\n            if (!mappingNesting) {\n                dependentObservables = [];\n                visitedObjects = new ObjectLookup();\n            }\n            mappingNesting++;\n\n            var options;\n            var target;\n\n            if (arguments.length === 2) {\n                if (arguments[1][mappingProperty]) {\n                    target = arguments[1];\n                }\n                else {\n                    options = arguments[1];\n                }\n            }\n            if (arguments.length === 3) {\n                options = arguments[1];\n                target = arguments[2];\n            }\n\n            if (target) {\n                options = merge(options, target[mappingProperty]);\n            }\n            options = fillOptions(options);\n\n            var result = updateViewModel(target, jsObject, options);\n            if (target) {\n                result = target;\n            }\n\n            // Evaluate any dependent observables that were proxied.\n            // Do this after the model's observables have been created\n            if (!--mappingNesting) {\n                while (dependentObservables.length) {\n                    var DO = dependentObservables.pop();\n                    if (DO) {\n                        DO();\n                        // Move this magic property to the underlying dependent observable\n                        DO.__DO[\"throttleEvaluation\"] = DO[\"throttleEvaluation\"];\n                    }\n                }\n            }\n\n            // Save any new mapping options in the view model, so that updateFromJS can use them later.\n            result[mappingProperty] = merge(result[mappingProperty], options);\n\n            return result;\n        }\n        catch (e) {\n            mappingNesting = 0;\n            throw e;\n        }\n    };\n\n    exports.fromJSON = function(jsonString /*, options, target*/) {\n        var args = Array.prototype.slice.call(arguments, 0);\n        args[0] = ko.utils.parseJson(jsonString);\n        return exports.fromJS.apply(this, args);\n    };\n\n    exports.toJS = function(rootObject, options) {\n        if (!defaultOptions) exports.resetDefaultOptions();\n\n        if (arguments.length === 0) throw new Error(\"When calling ko.mapping.toJS, pass the object you want to convert.\");\n        if (exports.getType(defaultOptions.ignore) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().ignore should be an array.\");\n        if (exports.getType(defaultOptions.include) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().include should be an array.\");\n        if (exports.getType(defaultOptions.copy) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().copy should be an array.\");\n\n        // Merge in the options used in fromJS\n        options = fillOptions(options, rootObject[mappingProperty]);\n\n        // We just unwrap everything at every level in the object graph\n        return exports.visitModel(rootObject, function(x) {\n            return ko.utils.unwrapObservable(x);\n        }, options);\n    };\n\n    exports.toJSON = function(rootObject, options, replacer, space) {\n        var plainJavaScriptObject = exports.toJS(rootObject, options);\n        return ko.utils.stringifyJson(plainJavaScriptObject, replacer, space);\n    };\n\n    exports.defaultOptions = function() {\n        if (arguments.length > 0) {\n            defaultOptions = arguments[0];\n        }\n        else {\n            return defaultOptions;\n        }\n    };\n\n    exports.resetDefaultOptions = function() {\n        defaultOptions = {\n            include: _defaultOptions.include.slice(0),\n            ignore: _defaultOptions.ignore.slice(0),\n            copy: _defaultOptions.copy.slice(0),\n            observe: _defaultOptions.observe.slice(0)\n        };\n    };\n\n    exports.getType = function(x) {\n        if ((x) && (typeof (x) === \"object\")) {\n            if (x.constructor === Date) return \"date\";\n            if (x.constructor === Array) return \"array\";\n        }\n        return typeof x;\n    };\n\n    function fillOptions(rawOptions, otherOptions) {\n        var options = merge({}, rawOptions);\n\n        // Move recognized root-level properties into a root namespace\n        for (var i = recognizedRootProperties.length - 1; i >= 0; i--) {\n            var property = recognizedRootProperties[i];\n\n            // Carry on, unless this property is present\n            if (!options[property]) continue;\n\n            // Move the property into the root namespace\n            if (!(options[\"\"] instanceof Object)) options[\"\"] = {};\n            options[\"\"][property] = options[property];\n            delete options[property];\n        }\n\n        if (otherOptions) {\n            options.ignore = mergeArrays(otherOptions.ignore, options.ignore);\n            options.include = mergeArrays(otherOptions.include, options.include);\n            options.copy = mergeArrays(otherOptions.copy, options.copy);\n            options.observe = mergeArrays(otherOptions.observe, options.observe);\n        }\n        options.ignore = mergeArrays(options.ignore, defaultOptions.ignore);\n        options.include = mergeArrays(options.include, defaultOptions.include);\n        options.copy = mergeArrays(options.copy, defaultOptions.copy);\n        options.observe = mergeArrays(options.observe, defaultOptions.observe);\n\n        options.mappedProperties = options.mappedProperties || {};\n        options.copiedProperties = options.copiedProperties || {};\n        return options;\n    }\n\n    function mergeArrays(a, b) {\n        if (a === undefined) {\n            a = [];\n        }\n        else if (exports.getType(a) !== \"array\") {\n            a = [a];\n        }\n\n        if (b === undefined) {\n            b = [];\n        }\n        else if (exports.getType(b) !== \"array\") {\n            b = [b];\n        }\n\n        return ko.utils.arrayGetDistinctValues(a.concat(b));\n    }\n\n    // When using a 'create' callback, we proxy the dependent observable so that it doesn't immediately evaluate on creation.\n    // The reason is that the dependent observables in the user-specified callback may contain references to properties that have not been mapped yet.\n    function withProxyDependentObservable(dependentObservables, callback) {\n        var localDO = ko.dependentObservable;\n        ko.dependentObservable = function(read, owner, options) {\n            options = options || {};\n\n            if (read && typeof read === \"object\") { // mirrors condition in knockout implementation of DO's\n                options = read;\n            }\n\n            var realDeferEvaluation = options.deferEvaluation;\n            var realIsPure = options.pure;\n\n            var isRemoved = false;\n\n            // We wrap the original dependent observable so that we can remove it from the 'dependentObservables' list we need to evaluate after mapping has\n            // completed if the user already evaluated the DO themselves in the meantime.\n            var wrap = function(DO) {\n                // Temporarily revert ko.dependentObservable, since it is used in ko.isWriteableObservable\n                var tmp = ko.dependentObservable;\n                ko.dependentObservable = realKoDependentObservable;\n                var isWriteable = ko.isWriteableObservable(DO);\n                ko.dependentObservable = tmp;\n\n                var wrapped = realKoDependentObservable({\n                    read: function() {\n                        if (!isRemoved) {\n                            ko.utils.arrayRemoveItem(dependentObservables, DO);\n                            isRemoved = true;\n                        }\n                        return DO.apply(DO, arguments);\n                    },\n                    write: isWriteable && function(val) {\n                        return DO(val);\n                    },\n                    deferEvaluation: true\n                });\n                if (DEBUG) wrapped._wrapper = true;\n                wrapped.__DO = DO;\n                return wrapped;\n            };\n\n            options.deferEvaluation = true; // will either set for just options, or both read/options.\n            var realDependentObservable = realKoDependentObservable(read, owner, options);\n\n            if (!realDeferEvaluation && !realIsPure) {\n                realDependentObservable = wrap(realDependentObservable);\n                dependentObservables.push(realDependentObservable);\n            }\n\n            return realDependentObservable;\n        };\n        ko.dependentObservable.fn = realKoDependentObservable.fn;\n        ko.computed = ko.dependentObservable;\n        var result = callback();\n        ko.dependentObservable = localDO;\n        ko.computed = ko.dependentObservable;\n        return result;\n    }\n\n    function updateViewModel(mappedRootObject, rootObject, options, parentName, parent, parentPropertyName, mappedParent) {\n        var isArray = exports.getType(ko.utils.unwrapObservable(rootObject)) === \"array\";\n\n        parentPropertyName = parentPropertyName || \"\";\n\n        // If this object was already mapped previously, take the options from there and merge them with our existing ones.\n        if (exports.isMapped(mappedRootObject)) {\n            var previousMapping = ko.utils.unwrapObservable(mappedRootObject)[mappingProperty];\n            options = merge(previousMapping, options);\n        }\n\n        var callbackParams = {\n            data: rootObject,\n            parent: mappedParent || parent\n        };\n\n        var hasCreateCallback = function() {\n            return options[parentName] && options[parentName].create instanceof Function;\n        };\n\n        var createCallback = function(data) {\n            return withProxyDependentObservable(dependentObservables, function() {\n\n                if (ko.utils.unwrapObservable(parent) instanceof Array) {\n                    return options[parentName].create({\n                        data: data || callbackParams.data,\n                        parent: callbackParams.parent,\n                        skip: emptyReturn\n                    });\n                }\n                else {\n                    return options[parentName].create({\n                        data: data || callbackParams.data,\n                        parent: callbackParams.parent\n                    });\n                }\n            });\n        };\n\n        var hasUpdateCallback = function() {\n            return options[parentName] && options[parentName].update instanceof Function;\n        };\n\n        var updateCallback = function(obj, data) {\n            var params = {\n                data: data || callbackParams.data,\n                parent: callbackParams.parent,\n                target: ko.utils.unwrapObservable(obj)\n            };\n\n            if (ko.isWriteableObservable(obj)) {\n                params.observable = obj;\n            }\n\n            return options[parentName].update(params);\n        };\n\n        var alreadyMapped = visitedObjects.get(rootObject);\n        if (alreadyMapped) {\n            return alreadyMapped;\n        }\n\n        parentName = parentName || \"\";\n\n        if (!isArray) {\n            // For atomic types, do a direct update on the observable\n            if (!canHaveProperties(rootObject)) {\n                switch (exports.getType(rootObject)) {\n                    case \"function\":\n                        if (hasUpdateCallback()) {\n                            if (ko.isWriteableObservable(rootObject)) {\n                                rootObject(updateCallback(rootObject));\n                                mappedRootObject = rootObject;\n                            }\n                            else {\n                                mappedRootObject = updateCallback(rootObject);\n                            }\n                        }\n                        else {\n                            mappedRootObject = rootObject;\n                        }\n                        break;\n                    default:\n                        if (ko.isWriteableObservable(mappedRootObject)) {\n                            var valueToWrite;\n                            if (hasUpdateCallback()) {\n                                valueToWrite = updateCallback(mappedRootObject);\n                                mappedRootObject(valueToWrite);\n                                return valueToWrite;\n                            }\n                            else {\n                                valueToWrite = ko.utils.unwrapObservable(rootObject);\n                                mappedRootObject(valueToWrite);\n                                return valueToWrite;\n                            }\n                        }\n                        else {\n                            var hasCreateOrUpdateCallback = hasCreateCallback() || hasUpdateCallback();\n\n                            if (hasCreateCallback()) {\n                                mappedRootObject = createCallback();\n                            }\n                            else {\n                                mappedRootObject = ko.observable(ko.utils.unwrapObservable(rootObject));\n                            }\n\n                            if (hasUpdateCallback()) {\n                                mappedRootObject(updateCallback(mappedRootObject));\n                            }\n\n                            if (hasCreateOrUpdateCallback) return mappedRootObject;\n                        }\n                }\n\n            }\n            else {\n                mappedRootObject = ko.utils.unwrapObservable(mappedRootObject);\n                if (!mappedRootObject) {\n                    if (hasCreateCallback()) {\n                        var result = createCallback();\n\n                        if (hasUpdateCallback()) {\n                            result = updateCallback(result);\n                        }\n                        return result;\n                    }\n                    else {\n                        if (hasUpdateCallback()) {\n                            //Removed ambiguous parameter result\n                            return updateCallback();\n                        }\n                        mappedRootObject = {};\n                    }\n                }\n\n                if (hasUpdateCallback()) {\n                    mappedRootObject = updateCallback(mappedRootObject);\n                }\n\n                visitedObjects.save(rootObject, mappedRootObject);\n                if (hasUpdateCallback()) return mappedRootObject;\n\n                // For non-atomic types, visit all properties and update recursively\n                visitPropertiesOrArrayEntries(rootObject, function(indexer) {\n                    var fullPropertyName = parentPropertyName.length ? parentPropertyName + \".\" + escapePropertyNameComponent(indexer) : escapePropertyNameComponent(indexer);\n\n                    if (ko.utils.arrayIndexOf(options.ignore, fullPropertyName) !== -1) {\n                        return;\n                    }\n\n                    if (ko.utils.arrayIndexOf(options.copy, fullPropertyName) !== -1) {\n                        mappedRootObject[indexer] = rootObject[indexer];\n                        return;\n                    }\n\n                    if (typeof rootObject[indexer] !== \"object\" && exports.getType(rootObject[indexer]) !== \"array\" && options.observe.length > 0 && ko.utils.arrayIndexOf(options.observe, fullPropertyName) === -1) {\n                        mappedRootObject[indexer] = rootObject[indexer];\n                        options.copiedProperties[fullPropertyName] = true;\n                        return;\n                    }\n\n                    // In case we are adding an already mapped property, fill it with the previously mapped property value to prevent recursion.\n                    // If this is a property that was generated by fromJS, we should use the options specified there\n                    var prevMappedProperty = visitedObjects.get(rootObject[indexer]);\n                    var retval = updateViewModel(mappedRootObject[indexer], rootObject[indexer], options, indexer, mappedRootObject, fullPropertyName, mappedRootObject);\n                    var value = prevMappedProperty || retval;\n\n                    if (options.observe.length > 0 && ko.utils.arrayIndexOf(options.observe, fullPropertyName) === -1) {\n                        mappedRootObject[indexer] = ko.utils.unwrapObservable(value);\n                        options.copiedProperties[fullPropertyName] = true;\n                        return;\n                    }\n\n                    if (ko.isWriteableObservable(mappedRootObject[indexer])) {\n                        value = ko.utils.unwrapObservable(value);\n                        if (mappedRootObject[indexer]() !== value) {\n                            mappedRootObject[indexer](value);\n                        }\n                    }\n                    else {\n                        value = mappedRootObject[indexer] === undefined ? value : ko.utils.unwrapObservable(value);\n                        mappedRootObject[indexer] = value;\n                    }\n\n                    options.mappedProperties[fullPropertyName] = true;\n                });\n            }\n        }\n        else { //mappedRootObject is an array\n            var changes = [];\n\n            var hasKeyCallback = false;\n            var keyCallback = function(x) {\n                return x;\n            };\n            if (options[parentName] && options[parentName].key) {\n                keyCallback = options[parentName].key;\n                hasKeyCallback = true;\n            }\n\n            if (!ko.isObservable(mappedRootObject)) {\n                // When creating the new observable array, also add a bunch of utility functions that take the 'key' of the array items into account.\n                mappedRootObject = ko.observableArray([]);\n\n                mappedRootObject.mappedRemove = function(valueOrPredicate) {\n                    var predicate = typeof valueOrPredicate === \"function\" ? valueOrPredicate : function(value) {\n                        return value === keyCallback(valueOrPredicate);\n                    };\n                    return mappedRootObject.remove(function(item) {\n                        return predicate(keyCallback(item));\n                    });\n                };\n\n                mappedRootObject.mappedRemoveAll = function(arrayOfValues) {\n                    var arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);\n                    return mappedRootObject.remove(function(item) {\n                        return ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) !== -1;\n                    });\n                };\n\n                mappedRootObject.mappedDestroy = function(valueOrPredicate) {\n                    var predicate = typeof valueOrPredicate === \"function\" ? valueOrPredicate : function(value) {\n                        return value === keyCallback(valueOrPredicate);\n                    };\n                    return mappedRootObject.destroy(function(item) {\n                        return predicate(keyCallback(item));\n                    });\n                };\n\n                mappedRootObject.mappedDestroyAll = function(arrayOfValues) {\n                    var arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);\n                    return mappedRootObject.destroy(function(item) {\n                        return ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) !== -1;\n                    });\n                };\n\n                mappedRootObject.mappedIndexOf = function(item) {\n                    var keys = filterArrayByKey(mappedRootObject(), keyCallback);\n                    var key = keyCallback(item);\n                    return ko.utils.arrayIndexOf(keys, key);\n                };\n\n                mappedRootObject.mappedGet = function(item) {\n                    return mappedRootObject()[mappedRootObject.mappedIndexOf(item)];\n                };\n\n                mappedRootObject.mappedCreate = function(value) {\n                    if (mappedRootObject.mappedIndexOf(value) !== -1) {\n                        throw new Error(\"There already is an object with the key that you specified.\");\n                    }\n                    var item = hasCreateCallback() ? createCallback(value) : value;\n                    if (hasUpdateCallback()) {\n                        var newValue = updateCallback(item, value);\n                        if (ko.isWriteableObservable(item)) {\n                            item(newValue);\n                        }\n                        else {\n                            item = newValue;\n                        }\n                    }\n                    mappedRootObject.push(item);\n                    return item;\n                };\n            }\n\n            var currentArrayKeys = filterArrayByKey(ko.utils.unwrapObservable(mappedRootObject), keyCallback).sort();\n            var newArrayKeys = filterArrayByKey(rootObject, keyCallback);\n            if (hasKeyCallback) newArrayKeys.sort();\n            var editScript = ko.utils.compareArrays(currentArrayKeys, newArrayKeys);\n\n            var ignoreIndexOf = {};\n\n            var i, j, key;\n\n            var unwrappedRootObject = ko.utils.unwrapObservable(rootObject);\n            var itemsByKey = {};\n            var optimizedKeys = true;\n            for (i = 0, j = unwrappedRootObject.length; i < j; i++) {\n                key = keyCallback(unwrappedRootObject[i]);\n                if (key === undefined || key instanceof Object) {\n                    optimizedKeys = false;\n                    break;\n                }\n                itemsByKey[key] = unwrappedRootObject[i];\n            }\n\n            var newContents = [];\n            var passedOver = 0;\n            var item, index;\n\n            for (i = 0, j = editScript.length; i < j; i++) {\n                key = editScript[i];\n                var mappedItem;\n                var fullPropertyName = parentPropertyName + \"[\" + escapePropertyNameComponent(i) + \"]\";\n\n                switch (key.status) {\n                    case \"added\":\n                        item = optimizedKeys ? itemsByKey[key.value] : getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);\n                        mappedItem = updateViewModel(undefined, item, options, parentName, mappedRootObject, fullPropertyName, parent);\n                        if (!hasCreateCallback()) {\n                            mappedItem = ko.utils.unwrapObservable(mappedItem);\n                        }\n\n                        index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);\n\n                        if (mappedItem === emptyReturn) {\n                            passedOver++;\n                        }\n                        else {\n                            newContents[index - passedOver] = mappedItem;\n                        }\n\n                        ignoreIndexOf[index] = true;\n                        break;\n                    case \"retained\":\n                        item = optimizedKeys ? itemsByKey[key.value] : getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);\n                        mappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);\n                        updateViewModel(mappedItem, item, options, parentName, mappedRootObject, fullPropertyName, parent);\n\n                        index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);\n                        newContents[index] = mappedItem;\n                        ignoreIndexOf[index] = true;\n                        break;\n                    case \"deleted\":\n                        mappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);\n                        break;\n                }\n\n                changes.push({\n                    event: key.status,\n                    item: mappedItem\n                });\n            }\n\n            mappedRootObject(newContents);\n\n            if (options[parentName] && options[parentName].arrayChanged) {\n                ko.utils.arrayForEach(changes, function(change) {\n                    options[parentName].arrayChanged(change.event, change.item);\n                });\n            }\n        }\n\n        return mappedRootObject;\n    }\n\n    function ignorableIndexOf(array, item, ignoreIndices) {\n        for (var i = 0, j = array.length; i < j; i++) {\n            if (ignoreIndices[i] === true) continue;\n            if (array[i] === item) return i;\n        }\n        return null;\n    }\n\n    function mapKey(item, callback) {\n        var mappedItem;\n        if (callback) mappedItem = callback(item);\n        if (exports.getType(mappedItem) === \"undefined\") mappedItem = item;\n\n        return ko.utils.unwrapObservable(mappedItem);\n    }\n\n    function getItemByKey(array, key, callback) {\n        array = ko.utils.unwrapObservable(array);\n        for (var i = 0, j = array.length; i < j; i++) {\n            var item = array[i];\n            if (mapKey(item, callback) === key) return item;\n        }\n\n        throw new Error(\"When calling ko.update*, the key '\" + key + \"' was not found!\");\n    }\n\n    function filterArrayByKey(array, callback) {\n        return ko.utils.arrayMap(ko.utils.unwrapObservable(array), function(item) {\n            if (callback) {\n                return mapKey(item, callback);\n            }\n            else {\n                return item;\n            }\n        });\n    }\n\n    function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {\n        if (exports.getType(rootObject) === \"array\") {\n            for (var i = 0; i < rootObject.length; i++)\n                visitorCallback(i);\n        }\n        else {\n            for (var propertyName in rootObject) {\n                if (rootObject.hasOwnProperty(propertyName)) {\n                    visitorCallback(propertyName);\n                }\n            }\n        }\n    }\n\n    function canHaveProperties(object) {\n        if (object === null) {\n            return false;\n        }\n        var type = exports.getType(object);\n        return (type === \"object\") || (type === \"array\");\n    }\n\n    // Based on the parentName, this creates a fully classified name of a property\n\n    function getPropertyName(parentName, parent, indexer) {\n        var propertyName = parentName || \"\";\n        if (exports.getType(parent) === \"array\") {\n            if (parentName) {\n                propertyName += \"[\" + escapePropertyNameComponent(indexer) + \"]\";\n            }\n        }\n        else {\n            if (parentName) {\n                propertyName += \".\";\n            }\n            propertyName += escapePropertyNameComponent(indexer);\n        }\n        return propertyName;\n    }\n\n    function escapePropertyNameComponent(indexer) {\n        var escapedIndexer  = (''+indexer)\n            .replace(/~/g, '~~')\n            .replace(/\\[/g, '~[')\n            .replace(/]/g, '~]')\n            .replace(/\\./g, '~.');\n        return escapedIndexer;\n    }\n\n\n    exports.visitModel = function(rootObject, callback, options) {\n        options = options || {};\n        options.visitedObjects = options.visitedObjects || new ObjectLookup();\n\n        var mappedRootObject;\n        var unwrappedRootObject = ko.utils.unwrapObservable(rootObject);\n\n        if (!canHaveProperties(unwrappedRootObject)) {\n            return callback(rootObject, options.parentName);\n        }\n        else {\n            options = fillOptions(options, unwrappedRootObject[mappingProperty]);\n\n            // Only do a callback, but ignore the results\n            callback(rootObject, options.parentName);\n            mappedRootObject = exports.getType(unwrappedRootObject) === \"array\" ? [] : {};\n        }\n\n        options.visitedObjects.save(rootObject, mappedRootObject);\n\n        var parentName = options.parentName;\n        visitPropertiesOrArrayEntries(unwrappedRootObject, function(indexer) {\n            var escapedIndexer = escapePropertyNameComponent(indexer);\n            if (options.ignore && ko.utils.arrayIndexOf(options.ignore, escapedIndexer) !== -1) return;\n\n            var propertyValue = unwrappedRootObject[indexer];\n            options.parentName = getPropertyName(parentName, unwrappedRootObject, indexer);\n\n            // If we don't want to explicitly copy the unmapped property...\n            if (ko.utils.arrayIndexOf(options.copy, escapedIndexer) === -1) {\n                // ...find out if it's a property we want to explicitly include\n                if (ko.utils.arrayIndexOf(options.include, escapedIndexer) === -1) {\n                    // The mapped properties object contains all the properties that were part of the original object.\n                    // If a property does not exist, and it is not because it is part of an array (e.g. \"myProp[3]\"), then it should not be unmapped.\n                    var unwrappedRootMappingProperty = unwrappedRootObject[mappingProperty];\n                    if (unwrappedRootMappingProperty) {\n                        var mappedProperties = unwrappedRootMappingProperty.mappedProperties;\n                        if (mappedProperties && !mappedProperties[escapedIndexer]) {\n                            var copiedProperties = unwrappedRootMappingProperty.copiedProperties;\n                            if (copiedProperties && !copiedProperties[escapedIndexer] && (exports.getType(unwrappedRootObject) !== \"array\")) {\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n\n            switch (exports.getType(ko.utils.unwrapObservable(propertyValue))) {\n                case \"object\":\n                case \"array\":\n                case \"undefined\":\n                    var previouslyMappedValue = options.visitedObjects.get(propertyValue);\n                    mappedRootObject[indexer] = (exports.getType(previouslyMappedValue) !== \"undefined\") ? previouslyMappedValue : exports.visitModel(propertyValue, callback, options);\n                    break;\n                default:\n                    mappedRootObject[indexer] = callback(propertyValue, options.parentName);\n            }\n        });\n\n        return mappedRootObject;\n    };\n\n    function SimpleObjectLookup() {\n        var keys = [];\n        var values = [];\n        this.save = function(key, value) {\n            var existingIndex = ko.utils.arrayIndexOf(keys, key);\n            if (existingIndex >= 0) values[existingIndex] = value;\n            else {\n                keys.push(key);\n                values.push(value);\n            }\n        };\n        this.get = function(key) {\n            var existingIndex = ko.utils.arrayIndexOf(keys, key);\n            var value = (existingIndex >= 0) ? values[existingIndex] : undefined;\n            return value;\n        };\n    }\n\n    function ObjectLookup() {\n        var buckets = {};\n\n        var findBucket = function(key) {\n            var bucketKey;\n            try {\n                bucketKey = key;//JSON.stringify(key);\n            }\n            catch (e) {\n                bucketKey = \"$$$\";\n            }\n\n            var bucket = buckets[bucketKey];\n            if (!buckets.hasOwnProperty(bucketKey)) {\n                bucket = new SimpleObjectLookup();\n                buckets[bucketKey] = bucket;\n            }\n            return bucket;\n        };\n\n        this.save = function(key, value) {\n            findBucket(key).save(key, value);\n        };\n        this.get = function(key) {\n            return findBucket(key).get(key);\n        };\n    }\n}));\n"],"sourceRoot":"/source/"}